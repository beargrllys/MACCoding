STRUCT 항공기_스케줄_구조체 { 항공기 이름, 출발지, 출발 시간, 도착지, 도착시간}

STRUCT 공항_스케줄_구조체 {항공기 이름, 기항기, 출발/도착, 시간}
// 구조체 선언

get_ALSData(항공기 스케줄 데이터 포인터){//main의 데이터 포인터에 텍스트 파일로부터 데이터를 입력해준다.
	스케줄데이터개수 
	WHILE(텍스트 파일이 끝날때까지){ //선언해야할 스케줄 데이터 수를 구한다. 
		텍스트 파일 1줄씩 읽기
		스케줄데이터개수 ++
	}
		
	항공기 배열 = 항공기 스케줄[스케줄데이터개수] //스케줄데이터개수만큼 동적할당

	WHILE(스케줄데이터개수 만큼)
	{
		임시_스케줄데이터 =  텍스트 파일의 한줄
		항공기 배열[카운트] 구조체 = TOKEN(임시_스케줄데이터 ) // 토큰을 통해 각 구조체의 모든 정보 입력  
	}

	RETURN 스케줄데이터개수 //데이터 크기는 반환한다.
}


filterData(항공기 스케줄 데이터 포인터, 스케줄데이터개수)//항공기 데이터를 공항 이착륙 데이터로 변환
{
	공항이착륙배열 = 공항_스케줄_구조체[스케줄데이터개수]
	WHILE(스케줄데이터개수만큼)
	{
		IF(항공기 출발지가 "인천" 이면)
		{
			공항이착륙배열[카운트] = 
			{
			항공기.이름 = 항공기.이름
			공항.도착지 = 항공기.도착지
			공항.출발/도착 = "출발"
			공항.시간 = 항공기.도착시간
			}
		}
		ELSE IF(항공기 도착지가 "인천" 이면)
		{
			공항이착륙배열[카운트] = 
			{
			항공기.이름 = 항공기.이름
			공항.출발지 = 항공기.출발지
			공항.출발/도착 = "도착"
			공항.시간 = 항공기.출발시간
			}
		}
	}
	RETURN 공항이착륙배열 포인터
}

quickSort(공항이착륙배열 포인터, 첫원소자리, 마지막원소자리)//퀵정렬 함수 시작
{
	//첫원소자리: 왼쪽, 마지막원소자리: 오른쪽
	IF(왼쪽이 오른쪽보다 클때){
		피벗 = partitionBlock(공항이착륙배열 포인터, 왼쪽, 오른쪽);//가장 왼쪽 피벗을 기준으로 크기별 분류
		quickSort(공항이착륙배열 포인터, 왼쪽, 피벗-1);
		quickSort(공항이착륙배열 포인터, 피벗+1, 오른쪽);
	}
}

partitionBlock(공항이착륙배열 포인터,왼쪽, 오른쪽)
{
	low = 왼쪽
	high = 오른쪽
	피벗 = 공항이착륙배열[왼쪽].시간
	DO
	{
		DO
		{
			low++
		}WHILE(low가 오른쪽 자리보다 넘어가거나 low에 해당하는 이착륙 시간이 피벗보다 작을경우까지 반복 )
		DO
		{
		}WHILE(high가 완쪽 자리보다 작아지거나 high에 해당하는 이착륙 시간이 피벗보다 클경우까지 반복 )
		IF(low가 high보다 작을경우)
		{
			swap(공항이착륙배열 포인터, low, high)
		}
	}WHILE(low가 high보다 작을때까지 반복)
	swap(공항이착륙배열 포인터, left, high)
	RETURN high
}

swap(공항이착륙배열 포인터, 변경원소1, 변경원소2){
	//구조체배열이라 값을 일일히 변경해줍니다.
}

insertSort(공항이착륙배열 포인터, 스케줄데이터개수)
{
	카운트1, 카운트2
	key = 임시 공항이착륙노드
	FOR(카운트1를 세면서 스케줄데이터개수만큼 반복)
	{
		key에다가 공항이착륙배열[카운트] 복사
		FOR(카운트1 이전 배열중 key보다 큰 원소를 만날때까지 카운트2를 세며 반복)
		{
			공항이착륙배열[카운트2]를 공항이착륙배열[카운트2+1]로 이동
		}
		빈 공항이착륙배열[카운트2]에다가 key 복사
	}
}

